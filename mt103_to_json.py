#!/usr/bin/env python3
"""
Command-line utility to convert MT103 messages to JSON format.

Usage:
    python mt103_to_json.py input.txt [output.json]
    
If output file is not specified, it will be generated by replacing
the input file's extension with .json
"""

import sys
import os
import argparse
import json
from pathlib import Path
from mt103_json import mt103_to_json, convert_file


def parse_arguments():
    """Parse command line arguments"""
    parser = argparse.ArgumentParser(
        description='Convert MT103 messages to JSON format',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s samples/mt103-input.txt
  %(prog)s input.txt output.json
  %(prog)s -p samples/*.txt
  %(prog)s --batch samples/
        """
    )
    
    parser.add_argument(
        'input',
        help='Input MT103 file path or directory (with --batch)'
    )
    
    parser.add_argument(
        'output',
        nargs='?',
        help='Output JSON file path (optional, auto-generated if not specified)'
    )
    
    parser.add_argument(
        '-p', '--pretty',
        action='store_true',
        help='Pretty print JSON output with indentation'
    )
    
    parser.add_argument(
        '-b', '--batch',
        action='store_true',
        help='Process all .txt files in the input directory'
    )
    
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Show detailed processing information'
    )
    
    parser.add_argument(
        '--validate',
        action='store_true',
        help='Validate the output JSON structure'
    )
    
    return parser.parse_args()


def validate_json_structure(json_data):
    """Validate that the JSON has the expected MT103 structure"""
    required_fields = ['MT103']
    mt103_fields = ['Application_Id', 'Service_Id', 'LT_Address', 'A']
    
    if 'MT103' not in json_data:
        return False, "Missing root 'MT103' object"
    
    mt103 = json_data['MT103']
    
    # Check for some essential fields
    missing_fields = []
    for field in ['Application_Id', 'Service_Id']:
        if field not in mt103:
            missing_fields.append(field)
    
    if missing_fields:
        return False, f"Missing required fields: {', '.join(missing_fields)}"
    
    # Check for text block
    if 'A' not in mt103:
        return False, "Missing text block 'A'"
    
    return True, "Valid MT103 JSON structure"


def process_file(input_path, output_path=None, pretty=False, verbose=False, validate=False):
    """Process a single MT103 file"""
    try:
        # Check if input file exists
        if not os.path.exists(input_path):
            print(f"Error: Input file '{input_path}' not found", file=sys.stderr)
            return False
        
        # Generate output path if not specified
        if output_path is None:
            base_name = os.path.splitext(input_path)[0]
            output_path = base_name + '.json'
        
        if verbose:
            print(f"Processing: {input_path} -> {output_path}")
        
        # Read and convert
        with open(input_path, 'r') as f:
            mt103_content = f.read()
        
        # Convert to JSON
        json_data = mt103_to_json(mt103_content)
        
        # Validate if requested
        if validate:
            is_valid, message = validate_json_structure(json_data)
            if verbose:
                print(f"  Validation: {message}")
            if not is_valid:
                print(f"Warning: {input_path}: {message}", file=sys.stderr)
        
        # Write output
        with open(output_path, 'w') as f:
            if pretty:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
            else:
                json.dump(json_data, f, ensure_ascii=False)
        
        if verbose:
            print(f"  Success: Created {output_path}")
        
        return True
        
    except Exception as e:
        print(f"Error processing {input_path}: {str(e)}", file=sys.stderr)
        return False


def process_batch(directory, pretty=False, verbose=False, validate=False):
    """Process all .txt files in a directory"""
    directory = Path(directory)
    
    if not directory.is_dir():
        print(f"Error: '{directory}' is not a directory", file=sys.stderr)
        return False
    
    txt_files = list(directory.glob('*.txt'))
    
    if not txt_files:
        print(f"No .txt files found in {directory}", file=sys.stderr)
        return False
    
    print(f"Found {len(txt_files)} files to process")
    
    success_count = 0
    for txt_file in txt_files:
        if process_file(str(txt_file), pretty=pretty, verbose=verbose, validate=validate):
            success_count += 1
    
    print(f"\nProcessed {success_count}/{len(txt_files)} files successfully")
    return success_count == len(txt_files)


def main():
    """Main entry point"""
    args = parse_arguments()
    
    if args.batch:
        # Batch processing mode
        success = process_batch(
            args.input,
            pretty=args.pretty,
            verbose=args.verbose,
            validate=args.validate
        )
    else:
        # Single file processing
        success = process_file(
            args.input,
            args.output,
            pretty=args.pretty,
            verbose=args.verbose,
            validate=args.validate
        )
    
    # Exit with appropriate code
    sys.exit(0 if success else 1)


if __name__ == '__main__':
    main()